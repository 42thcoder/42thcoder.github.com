<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jQuery | 不可知之地]]></title>
  <link href="http://oncoding.in/blog/categories/jquery/atom.xml" rel="self"/>
  <link href="http://oncoding.in/"/>
  <updated>2012-12-04T18:39:11+08:00</updated>
  <id>http://oncoding.in/</id>
  <author>
    <name><![CDATA[子不语]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jQuery学习笔记之jQuery基础篇]]></title>
    <link href="http://oncoding.in/blog/2012/06/06/jqueryxue-xi-bi-ji-zhi-jqueryji-chu-pian/"/>
    <updated>2012-06-06T18:09:00+08:00</updated>
    <id>http://oncoding.in/blog/2012/06/06/jqueryxue-xi-bi-ji-zhi-jqueryji-chu-pian</id>
    <content type="html"><![CDATA[<p>jQuery是目前最实用的JavaScript库，号称前端开发的利器，能大大简化开发，很有必要学习。这篇文章，是我通过阅读《<a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html">jQuery基本原理</a>》来了解jQuery时所做的读书笔记：只记重点，概括思想，以作备忘。</p>

<p>部分内容参考了阮一峰先生的博文<a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">《jQuery设计思想》</a>。如果想了解JavaScript的一些基础知识，请参看我的上一篇读书笔记<a href="http://oncoding.in/blog/2012/06/05/jqueryxue-xi-bi-ji-zhi-javascriptji-chu-yu-fa-pian/">《jQuery学习笔记之JavaScript基础语法篇》</a></p>

<h2>jQuery基础</h2>

<p>这一部分主要记录jQuery的基础知识。</p>

<h2>ready：一切的前提</h2>

<p>ready可以用来判断当前页面是否已经加载完毕</p>

<p>``` js
//常规写法
$(document).ready(function() {</p>

<pre><code>console.log('ready!');
</code></pre>

<p>});</p>

<p>//精简写法
$(function() {</p>

<pre><code>console.log('ready!');
</code></pre>

<p>})
```</p>

<!-- more -->


<p>``` js 指定某函数在页面加载完毕后执行
function readyFn() {</p>

<pre><code>console.log('run when page is ready.');
</code></pre>

<p>}</p>

<p>$(document).ready(readyFn);
```</p>

<h2>选择元素：最基础的功能</h2>

<p>使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（<strong>简写为$</strong>），然后得到被选中的元素。jQuery支持大部分的CSS3选择器，完整的列表请参考<a href="http://api.jquery.com/category/selectors/">jQuery官方API</a></p>

<h4>如何选择元素</h4>

<p>``` js 最常用的选择表达式
//选择整个文档对象
$(document)</p>

<p>//选择ID为myId的网页元素
$('#myId');</p>

<p>//选择class为myClass的div元素
$('div.myClass');</p>

<p>//选择name属性为first_name的input元素
$('input[name=first_name]');
```</p>

<p>``` js jQuery特殊的选择表达式
$('a:first') //选择网页中第一个a元素</p>

<p>$('tr:odd') //选择表格的奇数行</p>

<p>$('#myForm :input') // 选择表单中的input元素</p>

<p>$('div:visible') //选择可见的div元素</p>

<p>$('div:gt(2)') // 选择所有的div元素，除了前三个</p>

<p>$('div:animated') // 选择当前处于动画状态的div元素
```</p>

<h4>判断选择元素的操作是否成功</h4>

<p>使用 $() 指定一个选择器，将会返回一个对象。即使选择器没有包含任何元素，该对象的值也为true。</p>

<p>``` js
if ($('div.foo')) {</p>

<pre><code>//不管$('div.foo')的操作是否成功，此处的代码都会被执行 
</code></pre>

<p>}
```</p>

<p>正确的做法：测试返回对象的长度属性</p>

<p><code>js 测试选择器是否包含多个元素
if ($('div.foo').length) { ... }
</code></p>

<h4>在变量中保存选择器</h4>

<p><code>js
var $divs = $('div');
</code></p>

<p><strong>注意</strong>：当 DOM 改变时被保存的选择器不会自动更新。</p>

<h4>筛选结果集</h4>

<p>jQuery提供了各种强大的过滤器，对结果集进行筛选，缩小选择结果。</p>

<p>``` js
$('div').has('p'); // 选择包含p元素的div元素
$('div').not('.myClass'); //选择class不等于myClass的div元素
$('div').filter('.myClass'); //选择class等于myClass的div元素
$('div').first(); //选择第1个div元素
$('div').eq(5); //选择第6个div元素
````</p>

<p>同时，jQuery还提供了在DOM树上移动的功能</p>

<p><code>js
$('div').next('p'); //选择div元素后面的第一个p元素
$('div').parent(); //选择div元素的父元素
$('div').closest('form'); //选择离div最近的那个form父元素
$('div').children(); //选择div的所有子元素
$('div').siblings(); //选择div的同级元素
</code></p>

<h2>操作元素</h2>

<p>在成功选择元素后，jQuery支持对其进行一系列的操作</p>

<h4>链式操作</h4>

<p>选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来
。另外，jQuery还提供了.end()方法，使得结果集可以后退一步
``` js
$('#content')   //找到class为content的元素</p>

<pre><code>.find('h3') //选择所有的h3元素
.eq(2)  //选择第三个h3元素
    .html('new text for the third h3!') //将它的内容改为
.end() // 恢复选择器到 #content 中的所有 h3 部分 
.eq(0)
    .html('new text for the first h3!');
</code></pre>

<p>```
<strong>注意</strong>：大量的链式处理会给代码的修改和调试带来困难。</p>

<h4>Getters &amp; Setters</h4>

<p>Getters &amp; Setters“重载”了同一个函数，根据参数列表确定最终的操作。</p>

<p><code>js
$('h1').html(); //html()没有参数，表示取出h1的值
$('h1').html('Hello')   //html()有参数hello，表示对h1进行赋值  
</code></p>

<p>常见的Getters &amp; Setters函数：</p>

<ul>
<li>.html() html内容</li>
<li>.text() text内容</li>
<li>.attr() 某个属性的值</li>
<li>.width() 某个元素的宽度</li>
<li>.height() 某个元素的高度</li>
<li>.val() 表单元素的值</li>
</ul>


<p><strong>注意</strong>：如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。</p>

<h4>移动元素</h4>

<p>假定我们选中了一个div元素，需要把它移动到p元素后面。</p>

<p><code>js
//第一种方法是使用.insertAfter()，把div元素移动p元素后面：
$('div').insertAfter('p');
//第二种方法是使用.after()，把p元素加到div元素前面：
$('p').after('div');
</code></p>

<p>两种操作的<strong>区别</strong>：返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。</p>

<p>使用这种模式的操作方法，一共有四对：</p>

<ul>
<li>.insertAfter()和.after()：在现存元素的外部，从后面插入元素</li>
<li>.insertBefore()和.before()：在现存元素的外部，从前面插入元素</li>
<li>.appendTo()和.append()：在现存元素的内部，从后面插入元素</li>
<li>.prependTo()和.prepend()：在现存元素的内部，从前面插入元素</li>
</ul>


<p>``` js 使用appendTo()函数实现元素的移动
// 将第一个列表项作为最后一项
var $li = $('#myList li:first').appendTo('#myList');</p>

<p>// 同一问题的另一种处理
$('#myList').append($('#myList li:first'));
```</p>

<h4>拷贝元素</h4>

<p>在调用元素的移动函数之前，调用clone()函数即可。</p>

<h4>删除元素</h4>

<p>使用.remove()和.detach()函数可以实现。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。
清空元素内容（但是不删除该元素）使用.empty()。</p>

<h4>新建元素</h4>

<p>``` js
//创建新元素
$('<p>This is a new paragraph</p>');
$('<li class="new">new list item</li>');
//创建一个包含属性对象的新元素
$('<a/>', {</p>

<pre><code>html : 'This is a &lt;strong&gt;new&lt;/strong&gt; link',
'class' : 'new',
href : 'foo.html'
</code></pre>

<p>});
```
一个新元素被创建之后，它<strong>不会</strong>立刻被添加到页面中去，需要调用一次appendTo()函数。</p>

<p><code>js 添加新元素的完整示例
var $myNewElement = $('&lt;p&gt;New element&lt;/p&gt;');
$myNewElement.appendTo('#content');
</code></p>

<p>另外，需要添加多个新元素时，最好将其存储到数组中，再一次性的append。</p>

<p>``` js
var myItems = [], $myList = $('#myList');</p>

<p>for (var i=0; i&lt;100; i++) {</p>

<pre><code>myItems.push('&lt;li&gt;item ' + i + '&lt;/li&gt;');
</code></pre>

<p>}</p>

<p>$myList.append(myItems.join(''));
```</p>

<h2>工具方法</h2>

<p>jQuery提供了许多有用的工具方法，这些方法不需要选取元素就可以调用。</p>

<p><code>js $.trim()去除行间和末尾的空白。
$.trim('    大量额外空白    ');
// 返回 '大量额外空白'
</code></p>

<p>``` js $.each()在数组和对象上迭代。
$.each([ 'foo', 'bar', 'baz' ], function(idx, val) {</p>

<pre><code>console.log('element ' + idx + 'is ' + val);
</code></pre>

<p>});</p>

<p>$.each({ foo : 'bar', baz : 'bim' }, function(k, v) {</p>

<pre><code>console.log(k + ' : ' + v);
</code></pre>

<p>});
```</p>

<p> $.fn.each，也可用于在一个选择的元素中进行迭代。</p>

<p>``` js $.inArray()在数组中返回值索引，如果值不在数组中就为 -1 。
var myArray = [ 1, 2, 3, 5 ];</p>

<p>if ($.inArray(4, myArray) !== -1) {</p>

<pre><code>console.log('found it!');
</code></pre>

<p>}
```</p>

<p>``` js $.extend() 使用后面对象的属性改变第一个对象的属性。
var firstObject = { foo : 'bar', a : 'b' };
var secondObject = { foo : 'baz' };</p>

<p>var newObject = $.extend(firstObject, secondObject);
console.log(firstObject.foo); // 'baz'
console.log(newObject.foo);   // 'baz'
//如果你不打算改变任何对象你可传递 $.extend，作为第一个参数传递一个空对象。</p>

<p>var firstObject = { foo : 'bar', a : 'b' };
var secondObject = { foo : 'baz' };</p>

<p>var newObject = $.extend({}, firstObject, secondObject);
console.log(firstObject.foo); // 'bar'
console.log(newObject.foo);   // 'baz'
```</p>

<p>``` js $.proxy()返回一个函数它总是运行在一个提供的作用域里 — 就是说，this 的设置意味着内部传递函数到第二个参数。</p>

<p>var myFunction = function() { console.log(this); };
var myObject = { foo : 'bar' };</p>

<p>myFunction(); // 记录 window 对象</p>

<p>var myProxyFunction = $.proxy(myFunction, myObject);
myProxyFunction(); // 记录 myObject 对象
//如果你拥有一个带方法的对象，你能传递对象和方法名去返回一个总运行在对象作用域里的函数。</p>

<p>var myObject = {</p>

<pre><code>myFn : function() {
    console.log(this);
}
</code></pre>

<p>};</p>

<p>$('#foo').click(myObject.myFn); // 记录 DOM 元素 #foo
$('#foo').click($.proxy(myObject, 'myFn')); // 记录 myObject
```</p>

<h2>事件操作</h2>

<p>曾经有一段时间，在浏览器中处理事件十分的混乱，导致API各不相同，缺少一致性。jQuery提供了一个统一的API消除了浏览器之间的差异。</p>

<h4>绑定事件</h4>

<p>jQuery支持把事件直接绑定在元素上，可以使用bind()函数同时传入事件类型和回调函数作为参数。</p>

<p><code>js
$('input').bind(
　　　　'click change', //同时绑定click和change事件
　　　　function() {
　　　　　　alert('Hello');
　　　　}
　　);
</code></p>

<p>jQuery为常用事件提供一些快捷方法。</p>

<p><code>js
$('p').click(function(){
　　alert('Hello');
});
</code></p>

<p>只想让绑定的事件执行一次</p>

<p>``` js
$('p').one('click', function() {</p>

<pre><code>console.log('You just clicked this for the first time!');
$(this).click(function() { console.log('You have clicked this before!'); });
</code></pre>

<p>});
```
如果希望只在某个元素第一次被点击的时候做一些复杂的初始化， $.fn.one方法是很好的选择。</p>

<h4>事件对象</h4>

<p>所有的事件处理函数，都可以接受一个事件对象（event object）作为参数，比如下面例子中的e：
<code>js
$("p").click(function(e) {
　　alert(e.type); // "click"
});
</code></p>

<p>这个事件对象有一些很有用的属性和方法：</p>

<ul>
<li>event.pageX 事件发生时，鼠标距离网页左上角的水平距离</li>
<li>event.pageY 事件发生时，鼠标距离网页左上角的垂直距离</li>
<li>event.type 事件的类型（比如click）</li>
<li>event.which 按下了哪一个键</li>
<li>event.data 在事件对象上绑定数据，然后传入事件处理函数</li>
<li>event.target 事件针对的网页元素</li>
<li>event.preventDefault() 阻止事件的默认行为（比如点击链接，会自动打开新页面）</li>
<li>event.stopPropagation() 停止事件向上层元素冒泡</li>
</ul>


<p>在事件处理函数中，可以用this关键字，返回事件针对的DOM元素：</p>

<p>``` js
$('a').click(function(e) {</p>

<p>　　　　if ($(this).attr('href').match('evil')) { //如果确认为有害链接
　　　　　　e.preventDefault(); //阻止打开
　　　　　　$(this).addClass('evil'); //加上表示有害的class
　　　　}
　　});
```</p>

<p>回调函数中的上下文this会发生改变</p>

<p>``` js
$('.clicky').click(function() {</p>

<pre><code>//this指向事件的目标对象
assert( $(this).hasClass(".clicky") );
</code></pre>

<p>});
```</p>

<p>其中一个解决办法是在进入回调函数前，将上下文保存在一个局部变量中。</p>

<p>``` js</p>

<p>var self = this;</p>

<p>$('.clicky').click(function() {</p>

<pre><code>self.clickedClick();
</code></pre>

<p>});
```</p>

<p>另一种方法是使用代理函数将回调函数包装起来</p>

<p>``` js
$('.clicky').click($.proxy(function() {</p>

<pre><code>//上下文不会改变
</code></pre>

<p>}, this));
```</p>

<h4>支持事件列表</h4>

<ul>
<li>.blur() 表单元素失去焦点。</li>
<li>.change() 表单元素的值发生变化</li>
<li>.click() 鼠标单击</li>
<li>.dblclick() 鼠标双击</li>
<li>.focus() 表单元素获得焦点</li>
<li>.focusin() 子元素获得焦点</li>
<li>.focusout() 子元素失去焦点</li>
<li>.hover() 同时为mouseenter和mouseleave事件指定处理函数</li>
<li>.keydown() 按下键盘（长时间按键，只返回一个事件）</li>
<li>.keypress() 按下键盘（长时间按键，将返回多个事件）</li>
<li>.keyup() 松开键盘</li>
<li>.load() 元素加载完毕</li>
<li>.mousedown() 按下鼠标</li>
<li>.mouseenter() 鼠标进入（进入子元素不触发）</li>
<li>.mouseleave() 鼠标离开（离开子元素不触发）</li>
<li>.mousemove() 鼠标在元素内部移动</li>
<li>.mouseout() 鼠标离开（离开子元素也触发）</li>
<li>.mouseover() 鼠标进入（进入子元素也触发）</li>
<li>.mouseup() 松开鼠标</li>
<li>.ready() DOM加载完成</li>
<li>.resize() 浏览器窗口的大小发生改变</li>
<li>.scroll() 滚动条的位置发生变化</li>
<li>.select() 用户选中文本框中的内容</li>
<li>.submit() 用户递交表单</li>
<li>.toggle() 根据鼠标点击的次数，依次运行多个函数</li>
<li>.unload() 用户离开页面</li>
</ul>


<h4>解除绑定</h4>

<p>.unbind()用来解除事件绑定。</p>

<p><code>js
$('p').unbind('click');
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery学习笔记之JavaScript基础语法篇]]></title>
    <link href="http://oncoding.in/blog/2012/06/05/jqueryxue-xi-bi-ji-zhi-javascriptji-chu-yu-fa-pian/"/>
    <updated>2012-06-05T23:29:00+08:00</updated>
    <id>http://oncoding.in/blog/2012/06/05/jqueryxue-xi-bi-ji-zhi-javascriptji-chu-yu-fa-pian</id>
    <content type="html"><![CDATA[<p>jQuery是目前最实用的JavaScript库，号称前端开发的利器，能大大简化开发，很有必要学习。这篇文章，是我通过阅读《<a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html">jQuery基本原理</a>》来了解jQuery时所做的读书笔记：只记重点，概括思想，以作备忘。</p>

<h2>JavaScript基础语法</h2>

<p>这一部分主要记录JavaScript的<em>非常见</em>基本语法，适合看完W3Shool中JavaScript简介的人。</p>

<h4>逻辑表达式</h4>

<p>或运算符（ ||） 返回第一个值为真的操作数, 如果两个操作数的值都为假，则返回最后一个操作数。</p>

<p>与运算符（ &amp;&amp;） 返回第一个值为假的运算符，如果两个操作数的值都为真，则返回最后一个操作数。</p>

<p>该特性可用于取代if进行流程控制，非常优雅</p>

<p>``` js
// 当foo的值为真的时候执行doSomething来处理foo
foo &amp;&amp; doSomething(foo);</p>

<p>// 如果baz为真，则把baz的值赋给bar
// 否则bar的值为函数craetBar的返回值
var bar = baz || createBar();
```</p>

<!-- more -->


<h4>何时为真&amp;&amp;何时为假</h4>

<p><code>js 被判断为true的值
'0'; //字符串0。
'any string';//任意字符串。
[];  // 一个空数组。
{};  // 一个空对象。
1;   // 不为0的数。
</code></p>

<p><code>js 被判断为false的值
0;
'';  // 一个空串。
NaN; // JavaScript中的 "not-a-number"（NaN是一个不确定的数）。
null;
undefined;  // 注意 -- undefined 可以被重新定义!
</code></p>

<h4>把字符串转换为数字</h4>

<p>``` js
var foo = 1;
var bar = '2';</p>

<p>// 使用Number对象的构造函数
console.log(foo + Number(bar));
// 使用 + 进行强制类型转换
console.log(foo + +bar);
```</p>

<h4>比较运算符</h4>

<p>``` js
var foo = 1;
var bar = 0;
var baz = '1';
var bim = 2;</p>

<p>foo == baz; //返回真
foo === parseInt(baz);  //  返回真
bim > baz;  //返回真
```</p>

<h4>三元运算符</h4>

<p><code>js
//如果bar为1，则foo值为1
//否则，foo的值为0
var foo = bar ? 1 : 0
</code></p>

<h4>switch语句</h4>

<p>switch语句支持值为字符串。在JavaScript中很少使用switch语句，通过创建对象来实现更好。我没懂为什么更好，搜到挺有意思的文章，<a href="http://zhangjunhd.blog.51cto.com/113473/68070/">“使用面向对象技术取代switch和if”</a>，改天看看，mark。</p>

<p>``` js
var stuffToDo = {</p>

<pre><code>'bar' : function() { 
    alert('the value was bar -- yay!');
},

'baz' : function() { 
    alert('boo baz :(');
},

'default' : function() { 
    alert('everything else is just ok');
}
</code></pre>

<p>};</p>

<p>if (stuffToDo[foo]) {</p>

<pre><code>stuffToDo[foo]();
</code></pre>

<p>} else {</p>

<pre><code>stuffToDo['default']();
</code></pre>

<p>}
```</p>

<h4>数组</h4>

<p>``` js
// 获取测试数组长度
var myArray = [ 'hello', 'world' ];
console.log(myArray.length);   // logs 2</p>

<p>// 加入元素到数组中
var myArray = [ 'hello', 'world' ];
myArray.push('new');</p>

<p>// 数组元素的切割与合并
var myArray = [ 'h', 'e', 'l', 'l', 'o' ];
var myString = myArray.join('');   // 'hello'
var mySplit = myString.split('');  // [ 'h', 'e', 'l', 'l', 'o' ]
```</p>

<h4>函数</h4>

<h6>自执行匿名函数</h6>

<p>创建一个函数表述式然后立即执行函数，避免在代码中乱用全局命名空间</p>

<p>``` js
(function(){</p>

<pre><code>var foo = 'Hello world';
</code></pre>

<p>})();</p>

<p>console.log(foo);   // undefined!
```</p>

<h6>函数作为参数</h6>

<p>``` js 以参数的方式传递一个匿名函数
var myFn = function(fn) {</p>

<pre><code>var result = fn();
console.log(result);
</code></pre>

<p>};</p>

<p>myFn(function() { return 'hello world'; });   // logs 'hello world'
```</p>

<p>``` js 以参数的方式传递一个命名函数
var myFn = function(fn) {</p>

<pre><code>var result = fn();
console.log(result);
</code></pre>

<p>};</p>

<p>var myOtherFn = function() {</p>

<pre><code>return 'hello world';
</code></pre>

<p>};</p>

<p>myFn(myOtherFn);   // logs 'hello world'
```</p>

<h4>作用域</h4>

<p>声明变量时一定要加var关键字。否则，该变量被当做全局变量，即使该声明发生在函数内部</p>
]]></content>
  </entry>
  
</feed>
